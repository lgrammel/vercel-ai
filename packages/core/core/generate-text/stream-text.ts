import zodToJsonSchema from 'zod-to-json-schema';
import { LanguageModel } from '../language-model';
import { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';
import { Message } from '../prompt/message';
import { Tool } from '../tool';
import { runToolsTransformation } from './run-tools-transformation';
import { StreamTextHttpResponse } from './stream-text-http-response';
import { ToToolCall } from './tool-call';
import { ToToolResult } from './tool-result';

/**
 * Stream text generated by a language model.
 */
export async function streamText<TOOLS extends Record<string, Tool>>({
  model,
  maxCompletionTokens,
  temperature,
  presencePenalty,
  frequencyPenalty,
  tools,
  system,
  prompt,
  messages,
}: {
  model: LanguageModel;

  maxCompletionTokens?: number;
  temperature?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;

  tools?: TOOLS;

  system?: string;
  prompt?: string;
  messages?: Array<Message>;
}): Promise<StreamTextResult<TOOLS>> {
  const modelStream = await model.doStream({
    mode: {
      type: 'regular',
      tools:
        tools == null
          ? undefined
          : Object.entries(tools).map(([name, tool]) => ({
              type: 'function',
              name,
              description: tool.description,
              parameters: zodToJsonSchema(tool.parameters),
            })),
    },

    maxCompletionTokens,
    temperature,
    presencePenalty,
    frequencyPenalty,

    prompt: convertToLanguageModelPrompt({
      system,
      prompt,
      messages,
    }),
  });

  const toolStream = runToolsTransformation({
    tools,
    generatorStream: modelStream,
  });

  return new StreamTextResult(toolStream);
}

export type TextStreamPart<TOOLS extends Record<string, Tool>> =
  | {
      type: 'text-delta';
      textDelta: string;
    }
  | ({
      type: 'tool-call';
    } & ToToolCall<TOOLS>)
  | {
      type: 'error';
      error: unknown;
    }
  | ({
      type: 'tool-result';
    } & ToToolResult<TOOLS>);

export class StreamTextResult<TOOLS extends Record<string, Tool>> {
  private readonly rootStream: ReadableStream<TextStreamPart<TOOLS>>;

  readonly textStream: AsyncIterable<string>;

  readonly fullStream: AsyncIterable<TextStreamPart<TOOLS>>;

  constructor(stream: ReadableStream<TextStreamPart<TOOLS>>) {
    this.rootStream = stream;

    this.textStream = {
      [Symbol.asyncIterator](): AsyncIterator<string> {
        const reader = stream.getReader();
        return {
          next: async () => {
            // loops until a text delta is found or the stream is finished:
            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                return { value: null, done: true };
              }

              if (value.type === 'text-delta') {
                // do not stream empty text deltas:
                if (value.textDelta.length > 0) {
                  return { value: value.textDelta, done: false };
                }
              }
            }
          },
        };
      },
    };

    this.fullStream = {
      [Symbol.asyncIterator](): AsyncIterator<TextStreamPart<TOOLS>> {
        const reader = stream.getReader();
        return {
          next: async () => {
            // loops until a valid delta is found or the stream is finished:
            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                return { value: null, done: true };
              }

              if (value.type === 'text-delta') {
                // do not stream empty text deltas:
                if (value.textDelta.length > 0) {
                  return { value, done: false };
                }
              } else {
                return { value, done: false };
              }
            }
          },
        };
      },
    };
  }

  toResponse() {
    return new StreamTextHttpResponse(this.rootStream);
  }
}
